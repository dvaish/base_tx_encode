package encoder

import chisel3._
import chisel3.util._
object PcsRxState extends ChiselEnum {
  val IDLE,
      NON_IDLE_DETECT,
      CONFIRM,
      SSD1_VECTOR,
      SSD2_VECTOR,
      BAD_SSD,
      RECEIVE,
      CSReset,
      ESD1,
      ESD2 = Value
}

object PcsTxState extends ChiselEnum {
  val IDLE,
      SSD1_VECTOR,
      SSD2_VECTOR,
      SSD1_VECTOR_ERROR,
      SSD2_VECTOR_ERROR,
      TRANSMIT_DATA,
      TRANSMIT_ERROR,
      CSReset1,
      CSReset2,
      ESD1,
      ESD2 = Value
}

object PcsCodeGroups {

  /* ------------------------------------------------------------------
   *  Helper to build Vec(4,SInt(3.W)) from 4 Scala Ints (+2,+1,0,-1,-2)
   * ------------------------------------------------------------------ */
   def V(a: Int, b: Int, c: Int, d: Int): Vec[SInt] =
    VecInit(a.S(3.W), b.S(3.W), c.S(3.W), d.S(3.W))

  /* ----------- Table 40‑1 / 40‑2 code‑group patterns ---------------- */

  // Delimiters
  def SSD1       = V(+2, +2, +2, +2)
  def SSD2       = V(+2, +2, +2, -2)
  def ESD1       = V(+2, +2, +2, +2)
  def ESD2_0     = V(+2, +2, +2, -2)
  def ESD2_1     = V(+2, +2, -2, +2)
  def ESD2_2     = V(+2, -2, +2, +2)
  def ESD_ERR    = V(-2, +2, +2, +2)
  
  // Carrier-extension (half-duplex)
  def CEXT       = V(+2,  0,  0, +2)
  def CEXT_ERR   = V(-2, +2, +2, +2)

   def XMT_ERR: Seq[Vec[SInt]] = Seq(
    V(0,+2,+2,0), V(+1,+1,+2,+2), V(+2,+1,+1,+2), V(+2,+1,+2,+1), 
    V(0,+2,+1,+2), V(+1,+2,+2,0), V(+2,+1,+2,0)
  )

  def CSEXTEND_ERR: Seq[Vec[SInt]] = Seq(
    V(-2,+2,+2,-2), V(-1,-1,+2,+2), V(+2,-1,-1,+2), V(+2,-1,+2,-1), 
    V(-2,+2,-1,+2), V(-1,+2,+2,-2), V(+2,-1,+2,-2)
  )

  def CSEXTEND: Seq[Vec[SInt]] = Seq(
    V(+2,+2,+1,+1), V(+1,+2,+2,+1), V(+1,+2,+1,+2)
  )

  def CSRESET: Seq[Vec[SInt]] = Seq(
    V(+2,-2,-2,+2), V(+2,+2,-1,-1), V(-1,+2,+2,-1), V(-1,+2,-1,+2), 
    V(+2,-2,+2,-1), V(+2,-2,-1,+2), V(-1,-2,+2,+2), V(+2,-1,-2,+2)
  )

  def ESD2_Ext_0 = V(+2, +2, +2, -2)  // Valid ESD2 for CEXT=0
  def ESD2_Ext_1 = V(+2, +2, -2, +2)
  def ESD2_Ext_2 = V(+2, -2, +2, +2)

  def ValidDataGroups: Seq[Vec[SInt]] = Seq(
    V(0, 0, 0, 0), V(0, 0, +1, +1), V(0, +1, +1, 0), V(0, +1, 0, +1),
V(-2, 0, 0, 0), V(-2, 0, +1, +1), V(-2, +1, +1, 0), V(-2, +1, 0, +1),
V(0, -2, 0, 0), V(0, -2, +1, +1), V(0, -1, +1, 0), V(0, -1, 0, +1),
V(-2, -2, 0, 0), V(-2, -2, +1, +1), V(-2, -1, +1, 0), V(-2, -1, 0, +1),
V(0, 0, -2, 0), V(0, 0, -1, +1), V(0, +1, -1, 0), V(0, +1, -2, +1),
V(-2, 0, -2, 0), V(-2, 0, -1, +1), V(-2, +1, -1, 0), V(-2, +1, -2, +1),
V(0, -2, -2, 0), V(0, -2, -1, +1), V(0, -1, -1, 0), V(0, -1, -2, +1),
V(-2, -2, -2, 0), V(-2, -2, -1, +1), V(-2, -1, -1, 0), V(-2, -1, -2, +1),
V(0, 0, 0, -2), V(0, 0, +1, -1), V(0, +1, +1, -2), V(0, +1, 0, -1),
V(-2, 0, 0, -2), V(-2, 0, +1, -1), V(-2, +1, +1, -2), V(-2, +1, 0, -1),
V(0, -2, 0, -2), V(0, -2, +1, -1), V(0, -1, +1, -2), V(0, -1, 0, -1),
V(-2, -2, 0, -2), V(-2, -2, +1, -1), V(-2, -1, +1, -2), V(-2, -1, 0, -1),
V(0, 0, -2, -2), V(0, 0, -1, -1), V(0, +1, -1, -2), V(0, +1, -2, -1),
V(-2, 0, -2, -2), V(-2, 0, -1, -1), V(-2, +1, -1, -2), V(-2, +1, -2, -1),
V(0, -2, -2, -2), V(0, -2, -1, -1), V(0, -1, -1, -2), V(0, -1, -2, -1),
V(-2, -2, -2, -2), V(-2, -2, -1, -1), V(-2, -1, -1, -2), V(-2, -1, -2, -1),
V(+1, +1, +1, +1), V(+1, +1, 0, 0), V(+1, 0, 0, +1), V(+1, 0, +1, 0),
V(-1, +1, +1, +1), V(-1, +1, 0, 0), V(-1, 0, 0, +1), V(-1, 0, +1, 0),
V(+1, -1, +1, +1), V(+1, -1, 0, 0), V(+1, -2, 0, +1), V(+1, -2, +1, 0),
V(-1, -1, +1, +1), V(-1, -1, 0, 0), V(-1, -2, 0, +1), V(-1, -2, +1, 0),
V(+1, +1, -1, +1), V(+1, +1, -2, 0), V(+1, 0, -2, +1), V(+1, 0, -1, 0),
V(-1, +1, -1, +1), V(-1, +1, -2, 0), V(-1, 0, -2, +1), V(-1, 0, -1, 0),
V(+1, -1, -1, +1), V(+1, -1, -2, 0), V(+1, -2, -2, +1), V(+1, -2, -1, 0),
V(-1, -1, -1, +1), V(-1, -1, -2, 0), V(-1, -2, -2, +1), V(-1, -2, -1, 0),
V(+1, +1, +1, -1), V(+1, +1, 0, -2), V(+1, 0, 0, -1), V(+1, 0, +1, -2),
V(-1, +1, +1, -1), V(-1, +1, 0, -2), V(-1, 0, 0, -1), V(-1, 0, +1, -2),
V(+1, -1, +1, -1), V(+1, -1, 0, -2), V(+1, -2, 0, -1), V(+1, -2, +1, -2),
V(-1, -1, +1, -1), V(-1, -1, 0, -2), V(-1, -2, 0, -1), V(-1, -2, +1, -2),
V(+1, +1, -1, -1), V(+1, +1, -2, -2), V(+1, 0, -2, -1), V(+1, 0, -1, -2),
V(-1, +1, -1, -1), V(-1, +1, -2, -2), V(-1, 0, -2, -1), V(-1, 0, -1, -2),
V(+1, -1, -1, -1), V(+1, -1, -2, -2), V(+1, -2, -2, -1), V(+1, -2, -1, -2),
V(-1, -1, -1, -1), V(-1, -1, -2, -2), V(-1, -2, -2, -1), V(-1, -2, -1, -2),
V(+2, 0, 0, 0), V(+2, 0, +1, +1), V(+2, +1, +1, 0), V(+2, +1, 0, +1),
V(+2, -2, 0, 0), V(+2, -2, +1, +1), V(+2, -1, +1, 0), V(+2, -1, 0, +1),
V(+2, 0, -2, 0), V(+2, 0, -1, +1), V(+2, +1, -1, 0), V(+2, +1, -2, +1),
V(+2, -2, -2, 0), V(+2, -2, -1, +1), V(+2, -1, -1, 0), V(+2, -1, -2, +1),
V(+2, 0, 0, -2), V(+2, 0, +1, -1), V(+2, +1, +1, -2), V(+2, +1, 0, -1),
V(+2, -2, 0, -2), V(+2, -2, +1, -1), V(+2, -1, +1, -2), V(+2, -1, 0, -1),
V(+2, 0, -2, -2), V(+2, 0, -1, -1), V(+2, +1, -1, -2), V(+2, +1, -2, -1),
V(+2, -2, -2, -2), V(+2, -2, -1, -1), V(+2, -1, -1, -2), V(+2, -1, -2, -1),
V(0, 0, +2, 0), V(+1, +1, +2, 0), V(+1, 0, +2, +1), V(0, +1, +2, +1),
V(-2, 0, +2, 0), V(-1, +1, +2, 0), V(-1, 0, +2, +1), V(-2, +1, +2, +1),
V(0, -2, +2, 0), V(+1, -1, +2, 0), V(+1, -2, +2, +1), V(0, -1, +2, +1),
V(-2, -2, +2, 0), V(-1, -1, +2, 0), V(-1, -2, +2, +1), V(-2, -1, +2, +1),
V(0, 0, +2, -2), V(+1, +1, +2, -2), V(+1, 0, +2, -1), V(0, +1, +2, -1),
V(-2, 0, +2, -2), V(-1, +1, +2, -2), V(-1, 0, +2, -1), V(-2, +1, +2, -1),
V(0, -2, +2, -2), V(+1, -1, +2, -2), V(+1, -2, +2, -1), V(0, -1, +2, -1),
V(-2, -2, +2, -2), V(-1, -1, +2, -2), V(-1, -2, +2, -1), V(-2, -1, +2, -1),
V(0, +2, 0, 0), V(0, +2, +1, +1), V(+1, +2, 0, +1), V(+1, +2, +1, 0),
V(-2, +2, 0, 0), V(-2, +2, +1, +1), V(-1, +2, 0, +1), V(-1, +2, +1, 0),
V(0, +2, -2, 0), V(0, +2, -1, +1), V(+1, +2, -2, +1), V(+1, +2, -1, 0),
V(-2, +2, -2, 0), V(-2, +2, -1, +1), V(-1, +2, -2, +1), V(-1, +2, -1, 0),
V(0, +2, 0, -2), V(0, +2, +1, -1), V(+1, +2, 0, -1), V(+1, +2, +1, -2),
V(-2, +2, 0, -2), V(-2, +2, +1, -1), V(-1, +2, 0, -1), V(-1, +2, +1, -2),
V(0, +2, -2, -2), V(0, +2, -1, -1), V(+1, +2, -2, -1), V(+1, +2, -1, -2),
V(-2, +2, -2, -2), V(-2, +2, -1, -1), V(-1, +2, -2, -1), V(-1, +2, -1, -2),
V(0, 0, 0, +2), V(+1, +1, 0, +2), V(0, +1, +1, +2), V(+1, 0, +1, +2),
V(-2, 0, 0, +2), V(-1, +1, 0, +2), V(-2, +1, +1, +2), V(-1, 0, +1, +2),
V(0, -2, 0, +2), V(+1, -1, 0, +2), V(0, -1, +1, +2), V(+1, -2, +1, +2),
V(-2, -2, 0, +2), V(-1, -1, 0, +2), V(-2, -1, +1, +2), V(-1, -2, +1, +2),
V(0, 0, -2, +2), V(+1, +1, -2, +2), V(0, +1, -1, +2), V(+1, 0, -1, +2),
V(-2, 0, -2, +2), V(-1, +1, -2, +2), V(-2, +1, -1, +2), V(-1, 0, -1, +2),
V(0, -2, -2, +2), V(+1, -1, -2, +2), V(0, -1, -1, +2), V(+1, -2, -1, +2),
V(-2, -2, -2, +2), V(-1, -1, -2, +2), V(-2, -1, -1, +2), V(-1, -2, -1, +2)
  )

  /* ------------------ Match helpers ------------------ */

  def eq4(a: Vec[SInt], b: Vec[SInt]): Bool =
    a.zip(b).map { case (x, y) => x === y }.reduce(_ && _)

  def isSSD1(v: Vec[SInt]): Bool       = eq4(v, SSD1)
  def isSSD2(v: Vec[SInt]): Bool       = eq4(v, SSD2)
  def isESD1(v: Vec[SInt]): Bool       = eq4(v, ESD1)

  def isXmtErr(v: Vec[SInt]): Bool =
    XMT_ERR.map(g => eq4(v, g)).reduce(_ || _)

  def isCSExtendErr(v: Vec[SInt]): Bool =
    CSEXTEND_ERR.map(g => eq4(v, g)).reduce(_ || _)

  def isCSExtend(v: Vec[SInt]): Bool =
    CSEXTEND.map(g => eq4(v, g)).reduce(_ || _)

  def isCSReset(v: Vec[SInt]): Bool =
    CSRESET.map(g => eq4(v, g)).reduce(_ || _)

  def isESD2(v: Vec[SInt]): Bool =
    eq4(v, ESD2_0) || eq4(v, ESD2_1) || eq4(v, ESD2_2)

  def isESD2Ext0(v: Vec[SInt]): Bool = eq4(v, ESD2_Ext_0)
  def isESD2Ext1(v: Vec[SInt]): Bool = eq4(v, ESD2_Ext_1)
  def isESD2Ext2(v: Vec[SInt]): Bool = eq4(v, ESD2_Ext_2)

  def isCext(v: Vec[SInt]): Bool = eq4(v, CEXT)
  def isCextErr(v: Vec[SInt]): Bool = eq4(v, CEXT_ERR)

  def isEsdErr(v: Vec[SInt]): Bool = eq4(v, ESD_ERR)

  def isIdle(v: Vec[SInt]): Bool =
    v.map(symb => (symb === -2.S) || (symb === 0.S)).reduce(_ && _)

  def isDataCodeGroup(v: Vec[SInt]): Bool =
    ValidDataGroups.map(g => eq4(v, g)).reduce(_ || _)
}

